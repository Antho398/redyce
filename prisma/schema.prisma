// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String // Hashé en production
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects       Project[]
  messages       ChatMessage[]
  aiUsage        AIUsage[]
  memoires       Memoire[]
  companyProfile CompanyProfile?
  projectMembers ProjectMember[]
  comments       Comment[]

  @@map("users")
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents      Document[]
  memoires       Memoire[]
  messages       ChatMessage[]
  dpgfExtracts   DPGFStructured[]
  cctpGenerated  CCTPGenerated[]
  aiUsage        AIUsage[]
  requirements   Requirement[]
  memoireExports MemoireExport[]
  members        ProjectMember[]

  @@map("projects")
}

enum DocumentType {
  AE
  RC
  CCAP
  CCTP
  DPGF
  MODELE_MEMOIRE
  COMPANY_DOC
  AUTRE
}

// Statuts de traitement des documents AO pour extraction d'exigences
// WAITING = Upload ok, en file d'attente pour extraction
// PROCESSING = Extraction en cours
// DONE = Extraction terminée avec succès
// ERROR = Échec de l'extraction
enum DocumentProcessingStatus {
  WAITING
  PROCESSING
  DONE
  ERROR
}

model Document {
  id           String       @id @default(cuid())
  name         String
  fileName     String
  filePath     String
  fileSize     Int
  mimeType     String
  documentType DocumentType // Type obligatoire : AE, RC, CCAP, CCTP, DPGF, MODELE_MEMOIRE, AUTRE
  projectId    String
  status       String       @default("uploaded") // uploaded, processing, processed, error (pour parsing template)
  
  // Statuts d'extraction des exigences (documents AO uniquement)
  requirementStatus    DocumentProcessingStatus? // Statut d'extraction des exigences
  requirementProcessedAt DateTime?               // Date de fin d'extraction
  requirementErrorMessage String?                // Message d'erreur si échec
  
  metaJson     Json?        // Métadonnées additionnelles (nbSections, nbQuestions, etc.)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  project              Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  analyses             DocumentAnalysis[]
  knowledgeChunks      KnowledgeChunk[]
  dpgfExtracts         DPGFStructured[]
  requirementDocuments Requirement[]        @relation("RequirementDocument")
  memoireTemplates     Memoire[]            @relation("MemoireTemplate")
  memoireSources       MemoireSourceLink[]
  templateSections     TemplateSection[]
  templateQuestions    TemplateQuestion[]
  templateCompanyForm  TemplateCompanyForm?

  @@index([projectId])
  @@index([documentType])
  @@index([requirementStatus])
  @@map("documents")
}

model DocumentAnalysis {
  id           String   @id @default(cuid())
  documentId   String
  analysisType String // extraction, summary, qa, etc.
  status       String   @default("pending") // pending, processing, completed, error
  result       Json? // Résultat de l'analyse structuré
  error        String?
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@map("document_analyses")
}

// ============================================================================
// MODÈLE DE DONNÉES V1 - MÉMOIRES TECHNIQUES
// ============================================================================
//
// RÈGLES FONDAMENTALES V1 :
//
// 1. IMMUABILITÉ DES QUESTIONS
//    - TemplateQuestion : Une fois extraite, IMMUABLE (pas de modification silencieuse)
//    - Seule la suppression explicite par l'utilisateur est autorisée
//
// 2. LIEN QUESTION + VERSION POUR LES RÉPONSES
//    - MemoireSection.content est TOUJOURS liée à :
//      * Une question (via question/title qui référence TemplateQuestion)
//      * Une version (via memoireId qui référence Memoire)
//    - Identifiant composite : (memoireId + order)
//
// 3. VERSIONS = SNAPSHOTS FIGÉS
//    - Memoire avec versionNumber = snapshot à l'instant T
//    - Nouvelle version = clone complet des réponses
//    - isFrozen=true = version figée (read-only)
//
// 4. DONNÉES D'ENTREPRISE = GLOBALES AU PROJET
//    - TemplateCompanyForm lié au Document template (global au projet)
//    - Réutilisable entre tous les mémoires
//    - Snapshot lors de l'export dans la version
//
// 5. INTERDICTIONS
//    - INTERDIT : Réponses sans version (memoireId obligatoire)
//    - INTERDIT : Modification silencieuse de la structure des questions
//    - INTERDIT : Écrasement automatique sans action utilisateur explicite
//    - INTERDIT : Modification d'une version figée

// Mémoire technique (livrable principal Redyce V1)
// Chaque instance = une VERSION spécifique (snapshot à l'instant T)
model Memoire {
  id                 String   @id @default(cuid())
  projectId          String
  userId             String
  title              String
  status             String   @default("DRAFT") // DRAFT, IN_PROGRESS, READY, EXPORTED
  templateDocumentId String // Document de type MODELE_MEMOIRE obligatoire - IMMUABLE après création
  contentJson        Json? // Contenu structuré (sections/réponses) - optionnel V1
  contentText        String?  @db.Text // Version texte pour recherche
  versionNumber      Int      @default(1) // Numéro de version séquentiel (1, 2, 3...) - IMMUABLE
  parentMemoireId    String? // ID du mémoire parent (pour versioning) - chaîne de versions
  isFrozen           Boolean  @default(false) // Si true, la version est figée et ne peut plus être modifiée (read-only)
  metadata           Json? // Métadonnées (ex: snapshot des données entreprise lors de l'export)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  project       Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  template      Document         @relation("MemoireTemplate", fields: [templateDocumentId], references: [id], onDelete: Restrict)
  sections      MemoireSection[] // Réponses de cette version - TOUJOURS liées à cette version
  exports       MemoireExport[]
  parentMemoire Memoire?         @relation("MemoireVersioning", fields: [parentMemoireId], references: [id], onDelete: SetNull)
  childMemos    Memoire[]        @relation("MemoireVersioning") // Versions suivantes

  @@index([projectId])
  @@index([userId])
  @@index([status])
  @@index([templateDocumentId])
  @@index([createdAt])
  @@index([parentMemoireId])
  @@index([versionNumber])
  @@map("technical_memos")
}

// Section/Réponse du mémoire technique
// RÈGLE STRICTE : TOUJOURS liée à une version (memoireId obligatoire)
// Identifiant composite : (memoireId + order) pour unicité dans une version
// Référence implicite à TemplateQuestion via question/title (pour traçabilité)
model MemoireSection {
  id                   String    @id @default(cuid())
  memoireId            String // Version parente - OBLIGATOIRE (réponse toujours liée à une version)
  title                String // Titre de la section (copié du template)
  order                Int // Ordre d'affichage dans cette version (peut différer du template)
  question             String?   @db.Text // Texte de la question (référence au TemplateQuestion pour traçabilité)
  status               String    @default("DRAFT") // DRAFT, IN_PROGRESS, REVIEWED, VALIDATED
  content              String?   @db.Text // Contenu de la réponse (mutable uniquement si version non figée)
  validatedBy          String? // userId de la personne qui a validé la section
  validatedAt          DateTime? // Date de validation
  sourceRequirementIds String[] // IDs des exigences sources liées (pour traçabilité)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  memoire          Memoire             @relation(fields: [memoireId], references: [id], onDelete: Cascade)
  sourceLinks      MemoireSourceLink[]
  requirementLinks RequirementLink[]
  comments         Comment[]

  @@unique([memoireId, order]) // Unicité : une position = une réponse dans une version
  @@index([memoireId]) // Pour récupérer toutes les réponses d'une version
  @@index([order])
  @@index([status])
  @@map("memoire_sections")
}

// Lien entre une section mémoire et un document source (traçabilité)
// Permet de savoir quels documents ont été utilisés pour répondre à une section
model MemoireSourceLink {
  id         String   @id @default(cuid())
  sectionId  String
  documentId String
  relevance  Float? // Score de pertinence (0-1) - optionnel V1
  excerpt    String?  @db.Text // Extrait du document utilisé
  pageNumber Int? // Numéro de page si applicable
  metadata   Json?
  createdAt  DateTime @default(now())

  section  MemoireSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  document Document       @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([sectionId, documentId])
  @@index([sectionId])
  @@index([documentId])
  @@map("memoire_source_links")
}

// Sections/ITEMS extraites d'un template mémoire (ex: "ITEM 1: Moyens humains")
// RÈGLE STRICTE : IMMUABLE après extraction
// - Pas de modification silencieuse autorisée
// - Seule la suppression explicite par l'utilisateur est autorisée
model TemplateSection {
  id               String   @id @default(cuid())
  documentId       String // Document de type MODELE_MEMOIRE
  order            Int // Ordre d'affichage - IMMUABLE après extraction
  title            String // Titre de la section (ex: "ITEM 1: Moyens humains") - IMMUABLE
  required         Boolean  @default(true) // IMMUABLE après extraction
  sourceAnchorJson Json? // Métadonnées de position (page, position, etc.)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  document  Document           @relation(fields: [documentId], references: [id], onDelete: Cascade)
  questions TemplateQuestion[] // Questions de cette section

  @@unique([documentId, order])
  @@index([documentId])
  @@index([order])
  @@map("template_sections")
}

// Questions extraites d'un template mémoire
// RÈGLE STRICTE : IMMUABLE après extraction
// - title, order, questionType, required, isGroupHeader : IMMUABLES
// - Pas de modification silencieuse autorisée
// - Seule la suppression explicite par l'utilisateur est autorisée
// - L'ajout de nouvelles questions doit être explicite (action utilisateur)
model TemplateQuestion {
  id                  String   @id @default(cuid())
  documentId          String // Document de type MODELE_MEMOIRE
  sectionId           String? // Section parente (ITEM)
  order               Int // Ordre d'affichage dans la section - IMMUABLE
  title               String // Texte de la question - IMMUABLE
  questionType        String   @default("TEXT") // TEXT, YES_NO - IMMUABLE
  required            Boolean  @default(true) // IMMUABLE
  parentQuestionOrder Int? // Ordre de la question parente (si c'est une sous-question) - IMMUABLE
  isGroupHeader       Boolean  @default(false) // Si true, pas de réponse directe - IMMUABLE
  sourceAnchorJson    Json? // Métadonnées de position (page, position, etc.)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  document Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)
  section  TemplateSection? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([documentId, sectionId, order])
  @@index([documentId])
  @@index([sectionId])
  @@index([order])
  @@map("template_questions")
}

// Formulaire entreprise extrait du template
// RÈGLE : GLOBAL AU PROJET (lié au Document template, pas au mémoire)
// - Réutilisable entre tous les mémoires d'un même projet
// - Lors de l'export, un snapshot est créé dans Memoire.metadata
// - fields : Structure du formulaire [{label, type, required, value, ...}]
//   Peut contenir aussi "companyPresentation" (texte libre de présentation)
model TemplateCompanyForm {
  id          String   @id @default(cuid())
  documentId  String   @unique // Document de type MODELE_MEMOIRE - UNIQUE par template
  fields      Json // Structure du formulaire: [{label, type, required, value}] + companyPresentation
  extractedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("template_company_forms")
}

// Exigence extraite des documents AO (Appel d'Offres)
model Requirement {
  id          String   @id @default(cuid())
  projectId   String
  documentId  String? // Document source de l'exigence
  code        String? // Code de référence (ex: "REQ-001")
  title       String // Titre de l'exigence
  description String   @db.Text // Description détaillée
  category    String? // Catégorie (technique, administratif, etc.)
  priority    String? // LOW, MED, HIGH
  status      String   @default("A_TRAITER") // A_TRAITER, COVERED, SUPPRIMEE
  sourcePage  Int? // Numéro de page dans le document source
  sourceQuote String?  @db.Text // Citation exacte du document source
  contentHash String?  // Hash SHA256 pour dédoublonnage (projectId + documentId + title normalisé)
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project      Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  document     Document?         @relation("RequirementDocument", fields: [documentId], references: [id], onDelete: SetNull)
  sectionLinks RequirementLink[]

  @@unique([projectId, documentId, contentHash]) // Contrainte unique pour éviter les doublons
  @@index([projectId])
  @@index([documentId])
  @@index([category])
  @@index([status])
  @@index([priority])
  @@index([contentHash])
  @@map("requirements")
}

// Lien entre une exigence et une section mémoire
model RequirementLink {
  id            String   @id @default(cuid())
  sectionId     String
  requirementId String
  relevance     Float? // Score de pertinence (0-1)
  createdAt     DateTime @default(now())

  section     MemoireSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  requirement Requirement    @relation(fields: [requirementId], references: [id], onDelete: Cascade)

  @@unique([sectionId, requirementId])
  @@index([sectionId])
  @@index([requirementId])
  @@map("requirement_links")
}

// Export d'un mémoire technique (DOCX généré)
model MemoireExport {
  id        String   @id @default(cuid())
  memoireId String
  projectId String
  type      String   @default("DOCX") // DOCX, PDF, etc.
  status    String   @default("PENDING") // PENDING, COMPLETED, ERROR
  filePath  String? // Chemin du fichier généré
  fileName  String? // Nom du fichier
  error     String? // Message d'erreur si status = ERROR
  metadata  Json? // Métadonnées (sections manquantes, etc.)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memoire Memoire @relation(fields: [memoireId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([memoireId])
  @@index([projectId])
  @@index([status])
  @@index([createdAt])
  @@map("memoire_exports")
}

model ChatMessage {
  id        String   @id @default(cuid())
  userId    String
  projectId String?
  role      String // user, assistant, system
  content   String   @db.Text
  metadata  Json?
  createdAt DateTime @default(now())

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([projectId])
  @@map("chat_messages")
}

model KnowledgeChunk {
  id         String   @id @default(cuid())
  documentId String
  content    String   @db.Text
  embedding  String?  @db.Text // Vector embedding pour recherche sémantique
  metadata   Json?
  createdAt  DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("knowledge_chunks")
}

model DPGFStructured {
  id           String    @id @default(cuid())
  projectId    String
  documentId   String? // Document source duquel le DPGF a été extrait
  title        String
  reference    String?
  dateCreation DateTime?

  // Données structurées extraites
  data Json // Structure complète : articles, matériaux, prescriptions

  // Métadonnées
  status     String @default("extracted") // extracted, validated, archived
  confidence Float? // Score de confiance de l'extraction (0-1)
  metadata   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project       Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  document      Document?       @relation(fields: [documentId], references: [id], onDelete: SetNull)
  cctpGenerated CCTPGenerated[]

  @@index([projectId])
  @@index([documentId])
  @@index([status])
  @@map("dpgf_structured")
}

model CCTPGenerated {
  id        String  @id @default(cuid())
  projectId String
  dpgfId    String? // DPGF source utilisé pour générer le CCTP
  title     String
  reference String?

  // Contenu généré
  content   String @db.Text // Contenu complet du CCTP
  structure Json // Structure organisée du CCTP

  // Métadonnées
  status   String @default("draft") // draft, generated, finalized, archived
  version  Int    @default(1)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  dpgf    DPGFStructured? @relation(fields: [dpgfId], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([dpgfId])
  @@index([status])
  @@map("cctp_generated")
}

model AIUsage {
  id           String   @id @default(cuid())
  userId       String
  userEmail    String?
  model        String // gpt-4o, gpt-4o-mini, gpt-3.5-turbo, etc.
  inputTokens  Int
  outputTokens Int
  totalTokens  Int
  cost         Float
  operation    String // dpgf_extraction, cctp_generation, document_analysis, chat, etc.
  projectId    String?
  documentId   String?
  createdAt    DateTime @default(now())

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([projectId])
  @@index([createdAt])
  @@index([operation])
  @@map("ai_usage")
}

// Membre d'un projet (collaboration)
model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      String   @default("CONTRIBUTOR") // OWNER, CONTRIBUTOR, REVIEWER
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@map("project_members")
}

// Commentaire sur une section de mémoire
model Comment {
  id               String   @id @default(cuid())
  memoireSectionId String
  authorId         String
  parentCommentId  String? // Pour les réponses à un commentaire
  content          String   @db.Text
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  section       MemoireSection @relation(fields: [memoireSectionId], references: [id], onDelete: Cascade)
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentComment Comment?       @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies       Comment[]      @relation("CommentReplies")

  @@index([memoireSectionId])
  @@index([authorId])
  @@index([parentCommentId])
  @@map("comments")
}

// Profil entreprise global (ADN entreprise) - Transversal à tous les projets
model CompanyProfile {
  id            String   @id @default(cuid())
  userId        String   @unique // 1-1 avec User
  companyName   String
  description   String?  @db.Text // Présentation générale
  activities    String?  @db.Text // Corps d'état / spécialités
  workforce     String?  @db.Text // Effectifs globaux ou par métier
  equipment     String?  @db.Text // Moyens matériels
  qualitySafety String?  @db.Text // Qualité / sécurité / environnement
  references    String?  @db.Text // Références chantiers
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("company_profiles")
}
