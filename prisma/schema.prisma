// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String // Hashé en production
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects       Project[]
  messages       ChatMessage[]
  aiUsage        AIUsage[]
  memoires       Memoire[]
  companyProfile CompanyProfile?
  projectMembers ProjectMember[]
  comments       Comment[]

  @@map("users")
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents      Document[]
  memoires       Memoire[]
  messages       ChatMessage[]
  dpgfExtracts   DPGFStructured[]
  cctpGenerated  CCTPGenerated[]
  aiUsage        AIUsage[]
  requirements   Requirement[]
  memoireExports MemoireExport[]
  members        ProjectMember[]

  @@map("projects")
}

enum DocumentType {
  AE
  RC
  CCAP
  CCTP
  DPGF
  MODELE_MEMOIRE
  AUTRE
}

model Document {
  id           String       @id @default(cuid())
  name         String
  fileName     String
  filePath     String
  fileSize     Int
  mimeType     String
  documentType DocumentType // Type obligatoire : AE, RC, CCAP, CCTP, DPGF, MODELE_MEMOIRE, AUTRE
  projectId    String
  status       String       @default("uploaded") // uploaded, processing, processed, error
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  project              Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  analyses             DocumentAnalysis[]
  knowledgeChunks      KnowledgeChunk[]
  dpgfExtracts         DPGFStructured[]
  requirementDocuments Requirement[]        @relation("RequirementDocument")
  memoireTemplates     Memoire[]            @relation("MemoireTemplate")
  memoireSources       MemoireSourceLink[]
  templateSections     TemplateSection[]
  templateQuestions    TemplateQuestion[]
  templateCompanyForm  TemplateCompanyForm?

  @@index([projectId])
  @@index([documentType])
  @@map("documents")
}

model DocumentAnalysis {
  id           String   @id @default(cuid())
  documentId   String
  analysisType String // extraction, summary, qa, etc.
  status       String   @default("pending") // pending, processing, completed, error
  result       Json? // Résultat de l'analyse structuré
  error        String?
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@map("document_analyses")
}

// Mémoire technique (livrable principal Redyce V1)
// Output principal : généré/édité par l'utilisateur pour répondre aux appels d'offres
model Memoire {
  id                 String   @id @default(cuid())
  projectId          String
  userId             String
  title              String
  status             String   @default("DRAFT") // DRAFT, IN_PROGRESS, READY, EXPORTED
  templateDocumentId String // Document de type MODELE_MEMOIRE obligatoire
  contentJson        Json? // Contenu structuré (sections/réponses) - optionnel V1
  contentText        String?  @db.Text // Version texte pour recherche
  versionNumber      Int      @default(1) // Numéro de version (1, 2, 3...)
  parentMemoireId    String? // ID du mémoire parent (pour versioning)
  isFrozen           Boolean  @default(false) // Si true, la version est figée et ne peut plus être modifiée
  metadata           Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  project       Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  template      Document         @relation("MemoireTemplate", fields: [templateDocumentId], references: [id], onDelete: Restrict)
  sections      MemoireSection[]
  exports       MemoireExport[]
  parentMemoire Memoire?         @relation("MemoireVersioning", fields: [parentMemoireId], references: [id], onDelete: SetNull)
  childMemos    Memoire[]        @relation("MemoireVersioning")

  @@index([projectId])
  @@index([userId])
  @@index([status])
  @@index([templateDocumentId])
  @@index([createdAt])
  @@index([parentMemoireId])
  @@index([versionNumber])
  @@map("technical_memos")
}

// Section du mémoire technique (extrait du template)
// Chaque section correspond à une question/rubrique du template client
model MemoireSection {
  id                   String    @id @default(cuid())
  memoireId            String
  title                String
  order                Int // Ordre d'affichage
  question             String?   @db.Text // Question si présente dans le template
  status               String    @default("DRAFT") // DRAFT, IN_PROGRESS, COMPLETED, VALIDATED
  content              String?   @db.Text // Contenu de la réponse
  validatedBy          String? // userId de la personne qui a validé la section
  validatedAt          DateTime? // Date de validation
  sourceRequirementIds String[] // IDs des exigences sources liées (pour traçabilité)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  memoire          Memoire             @relation(fields: [memoireId], references: [id], onDelete: Cascade)
  sourceLinks      MemoireSourceLink[]
  requirementLinks RequirementLink[]
  comments         Comment[]

  @@unique([memoireId, order])
  @@index([memoireId])
  @@index([order])
  @@index([status])
  @@map("memoire_sections")
}

// Lien entre une section mémoire et un document source (traçabilité)
// Permet de savoir quels documents ont été utilisés pour répondre à une section
model MemoireSourceLink {
  id         String   @id @default(cuid())
  sectionId  String
  documentId String
  relevance  Float? // Score de pertinence (0-1) - optionnel V1
  excerpt    String?  @db.Text // Extrait du document utilisé
  pageNumber Int? // Numéro de page si applicable
  metadata   Json?
  createdAt  DateTime @default(now())

  section  MemoireSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  document Document       @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([sectionId, documentId])
  @@index([sectionId])
  @@index([documentId])
  @@map("memoire_source_links")
}

// Sections/ITEMS extraites d'un template mémoire (ex: "ITEM 1: Moyens humains")
model TemplateSection {
  id               String   @id @default(cuid())
  documentId       String // Document de type MODELE_MEMOIRE
  order            Int // Ordre d'affichage
  title            String // Titre de la section (ex: "ITEM 1: Moyens humains")
  required         Boolean  @default(true)
  sourceAnchorJson Json? // Métadonnées de position (page, position, etc.)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  document  Document           @relation(fields: [documentId], references: [id], onDelete: Cascade)
  questions TemplateQuestion[]

  @@unique([documentId, order])
  @@index([documentId])
  @@index([order])
  @@map("template_sections")
}

// Questions extraites d'un template mémoire
// Chaque question appartient à une section (ITEM)
model TemplateQuestion {
  id                 String   @id @default(cuid())
  documentId         String // Document de type MODELE_MEMOIRE
  sectionId          String? // Section parente (ITEM)
  order              Int // Ordre d'affichage dans la section
  title              String // Texte de la question
  questionType       String   @default("TEXT") // TEXT, YES_NO (question avec checkbox oui/non)
  required           Boolean  @default(true)
  parentQuestionOrder Int? // Ordre de la question parente (si c'est une sous-question)
  isGroupHeader      Boolean  @default(false) // Si true, c'est un titre de groupe qui ne demande pas de réponse directe
  sourceAnchorJson   Json? // Métadonnées de position (page, position, etc.)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  document Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)
  section  TemplateSection? @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([documentId, sectionId, order])
  @@index([documentId])
  @@index([sectionId])
  @@index([order])
  @@map("template_questions")
}

// Formulaire entreprise extrait du template
// Chaque template peut avoir un formulaire différent (nom, qualité, etc.)
model TemplateCompanyForm {
  id          String   @id @default(cuid())
  documentId  String   @unique // Document de type MODELE_MEMOIRE
  fields      Json // Structure du formulaire: [{label, type, required, value}]
  extractedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("template_company_forms")
}

// Exigence extraite des documents AO (Appel d'Offres)
model Requirement {
  id          String   @id @default(cuid())
  projectId   String
  documentId  String? // Document source de l'exigence
  code        String? // Code de référence (ex: "REQ-001")
  title       String // Titre de l'exigence
  description String   @db.Text // Description détaillée
  category    String? // Catégorie (technique, administratif, etc.)
  priority    String? // LOW, MED, HIGH
  status      String   @default("TODO") // TODO, IN_PROGRESS, COVERED
  sourcePage  Int? // Numéro de page dans le document source
  sourceQuote String?  @db.Text // Citation exacte du document source
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project      Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  document     Document?         @relation("RequirementDocument", fields: [documentId], references: [id], onDelete: SetNull)
  sectionLinks RequirementLink[]

  @@index([projectId])
  @@index([documentId])
  @@index([category])
  @@index([status])
  @@index([priority])
  @@map("requirements")
}

// Lien entre une exigence et une section mémoire
model RequirementLink {
  id            String   @id @default(cuid())
  sectionId     String
  requirementId String
  relevance     Float? // Score de pertinence (0-1)
  createdAt     DateTime @default(now())

  section     MemoireSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  requirement Requirement    @relation(fields: [requirementId], references: [id], onDelete: Cascade)

  @@unique([sectionId, requirementId])
  @@index([sectionId])
  @@index([requirementId])
  @@map("requirement_links")
}

// Export d'un mémoire technique (DOCX généré)
model MemoireExport {
  id        String   @id @default(cuid())
  memoireId String
  projectId String
  type      String   @default("DOCX") // DOCX, PDF, etc.
  status    String   @default("PENDING") // PENDING, COMPLETED, ERROR
  filePath  String? // Chemin du fichier généré
  fileName  String? // Nom du fichier
  error     String? // Message d'erreur si status = ERROR
  metadata  Json? // Métadonnées (sections manquantes, etc.)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memoire Memoire @relation(fields: [memoireId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([memoireId])
  @@index([projectId])
  @@index([status])
  @@index([createdAt])
  @@map("memoire_exports")
}

model ChatMessage {
  id        String   @id @default(cuid())
  userId    String
  projectId String?
  role      String // user, assistant, system
  content   String   @db.Text
  metadata  Json?
  createdAt DateTime @default(now())

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([projectId])
  @@map("chat_messages")
}

model KnowledgeChunk {
  id         String   @id @default(cuid())
  documentId String
  content    String   @db.Text
  embedding  String?  @db.Text // Vector embedding pour recherche sémantique
  metadata   Json?
  createdAt  DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("knowledge_chunks")
}

model DPGFStructured {
  id           String    @id @default(cuid())
  projectId    String
  documentId   String? // Document source duquel le DPGF a été extrait
  title        String
  reference    String?
  dateCreation DateTime?

  // Données structurées extraites
  data Json // Structure complète : articles, matériaux, prescriptions

  // Métadonnées
  status     String @default("extracted") // extracted, validated, archived
  confidence Float? // Score de confiance de l'extraction (0-1)
  metadata   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project       Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  document      Document?       @relation(fields: [documentId], references: [id], onDelete: SetNull)
  cctpGenerated CCTPGenerated[]

  @@index([projectId])
  @@index([documentId])
  @@index([status])
  @@map("dpgf_structured")
}

model CCTPGenerated {
  id        String  @id @default(cuid())
  projectId String
  dpgfId    String? // DPGF source utilisé pour générer le CCTP
  title     String
  reference String?

  // Contenu généré
  content   String @db.Text // Contenu complet du CCTP
  structure Json // Structure organisée du CCTP

  // Métadonnées
  status   String @default("draft") // draft, generated, finalized, archived
  version  Int    @default(1)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  dpgf    DPGFStructured? @relation(fields: [dpgfId], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([dpgfId])
  @@index([status])
  @@map("cctp_generated")
}

model AIUsage {
  id           String   @id @default(cuid())
  userId       String
  userEmail    String?
  model        String // gpt-4o, gpt-4o-mini, gpt-3.5-turbo, etc.
  inputTokens  Int
  outputTokens Int
  totalTokens  Int
  cost         Float
  operation    String // dpgf_extraction, cctp_generation, document_analysis, chat, etc.
  projectId    String?
  documentId   String?
  createdAt    DateTime @default(now())

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([projectId])
  @@index([createdAt])
  @@index([operation])
  @@map("ai_usage")
}

// Membre d'un projet (collaboration)
model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      String   @default("CONTRIBUTOR") // OWNER, CONTRIBUTOR, REVIEWER
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@map("project_members")
}

// Commentaire sur une section de mémoire
model Comment {
  id               String   @id @default(cuid())
  memoireSectionId String
  authorId         String
  parentCommentId  String? // Pour les réponses à un commentaire
  content          String   @db.Text
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  section       MemoireSection @relation(fields: [memoireSectionId], references: [id], onDelete: Cascade)
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentComment Comment?       @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies       Comment[]      @relation("CommentReplies")

  @@index([memoireSectionId])
  @@index([authorId])
  @@index([parentCommentId])
  @@map("comments")
}

// Profil entreprise global (ADN entreprise) - Transversal à tous les projets
model CompanyProfile {
  id            String   @id @default(cuid())
  userId        String   @unique // 1-1 avec User
  companyName   String
  description   String?  @db.Text // Présentation générale
  activities    String?  @db.Text // Corps d'état / spécialités
  workforce     String?  @db.Text // Effectifs globaux ou par métier
  equipment     String?  @db.Text // Moyens matériels
  qualitySafety String?  @db.Text // Qualité / sécurité / environnement
  references    String?  @db.Text // Références chantiers
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("company_profiles")
}
